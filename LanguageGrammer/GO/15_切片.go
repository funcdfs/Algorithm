/*

切片（slice）是对数组一个连续片段的引用（该数组我们称之为相关数组，通常是匿名的），
所以切片是一个引用类型（因此更类似于 C/C++ 中的数组类型，或者 Python 中的 list 类型）。
这个片段可以是整个数组，或者是由起始和终止索引标识的一些项的子集。
需要注意的是，终止索引标识的项不包括在切片内。切片提供了一个相关数组的动态窗口。


切片提供了计算容量的函数 cap() 可以测量切片最长可以达到多少：
它等于切片的长度 + 数组除切片之外的长度。如果 s 是一个切片，cap(s) 就是从 s[0] 到数组末尾的数组长度。
切片的长度永远不会超过它的容量，所以对于 切片 s 来说该不等式永远成立：0 <= len(s) <= cap(s)。

优点 
因为切片是引用，所以它们不需要使用额外的内存并且比使用数组更有效率，所以在 Go 代码中 切片比数组更常用。


声明切片的格式是： var identifier []type（不需要说明长度）。

一个切片在未初始化之前默认为 nil，长度为 0。





切片的初始化格式是：var slice1 []type = arr1[start:end]。

这表示 slice1 是由数组 arr1 从 start 索引到 end-1 索引之间的元素构成的子集
（切分数组，start:end 被称为 slice 表达式）。
所以 slice1[0] 就等于 arr1[start]。这可以在 arr1 被填充前就定义好。

如果某个人写：var slice1 []type = arr1[:]  (未声明，start end)
那么 slice1 就等于完整的 arr1 数组（所以这种表示方式是 arr1[0:len(arr1)] 的一种缩写）。
另外一种表述方式是：slice1 = &arr1。

arr1[2:] 和 arr1[2:len(arr1)] 相同，都包含了数组从第三个到最后的所有元素。
arr1[:3] 和 arr1[0:3] 相同，包含了从第一个到第三个元素（不包括第四个）。

但是，我觉得应该不为了省略而省略，直接写上别人看的也会更加清楚






如果你想去掉 slice1 的最后一个元素，只要 slice1 = slice1[:len(slice1)-1]。
一个由数字 1、2、3 组成的切片可以这么生成：s := [3]int{1,2,3}[:]
(注: 应先用s := [3]int{1, 2, 3}生成数组, 再使用s[:]转成切片) 甚至更简单的 s := []int{1,2,3}。

s2 := s[:] 是用切片组成的切片，拥有相同的元素，但是仍然指向相同的相关数组。（数组的引用）



对于每一个切片（包括 string），以下状态总是成立的：
s == s[:i] + s[i:] // i是一个整数且: 0 <= i <= len(s)
len(s) <= cap(s)





如果 s2 是一个 slice，你可以将 s2 向后移动一位 s2 = s2[1:]，
但是末尾没有移动。切片只能向后移动，s2 = s2[-1:] 会导致编译错误。切片不能被重新分片以获取数组的前一个元素。


*/


// 将切片传递给函数

package main 

func sum(a []int) int {
	s := 0
	for i := 0; i < len(a); i++ {
		s += a[i]
	}
	return s
}

func main_切片() {
	var arr = [5]int{0, 1, 2, 3, 4}
	sum(arr[:])
}

/*

当相关数组还没有定义时，我们可以使用 make() 函数来创建一个切片 
同时创建好相关数组：var slice1 []type = make([]type, len)。

也可以简写为 slice1 := make([]type, len)，这里 len 是数组的长度并且也是 slice 的初始长度。

所以定义 s2 := make([]int, 10)，那么 cap(s2) == len(s2) == 10。

make 接受 2 个参数：元素的类型以及切片的元素个数。

如果你想创建一个 slice1，它不占用整个数组，而只是占用以 len 为个数个项，
那么只要：slice1 := make([]type, len, cap)。


make 的使用方式是：func make([]T, len, cap)，其中 cap 是可选参数。

所以下面两种方法可以生成相同的切片:
make([]int, 50, 100) // 函数写法
new([100]int)[0:50]  // new 写法

TODO new和 make 的区别
TODO 多维切片
TODO bytes 包

https://go.dev/blog/slices-intro

*/
